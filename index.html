<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RetroChat - IRC Style with SDS</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono:wght@400&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Share Tech Mono', monospace;
      background: #000;
      color: #00ff00;
      min-height: 100vh;
      height: 100vh;
      margin: 0;
      padding: 0;
      overflow: hidden;
      position: relative;
    }

    @supports (-webkit-touch-callout: none) {
      body {
        min-height: -webkit-fill-available;
        height: -webkit-fill-available;
      }
    }

    .app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      position: relative;
    }

    @supports (-webkit-touch-callout: none) {
      .app-container {
        height: -webkit-fill-available;
      }
    }

    .header {
      background: #001100;
      border-bottom: 2px solid #00ff00;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 1000;
      flex-shrink: 0;
    }

    .title {
      font-size: 18px;
      color: #00ff00;
      text-shadow: 0 0 10px #00ff00;
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .nickname-input {
      background: #000;
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 5px 10px;
      font-family: inherit;
      font-size: 14px;
    }

    .nickname-input:focus {
      outline: none;
      box-shadow: 0 0 5px #00ff00;
    }

    .status-group {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
    }

    .status {
      color: #ffff00;
      font-size: 12px;
    }

    .node-count {
      color: #00ffff;
      font-size: 11px;
      cursor: help;
      position: relative;
    }

    .node-count .tooltip {
      visibility: hidden;
      opacity: 0;
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 5px;
      background: #001100;
      color: #00ff00;
      padding: 8px 12px;
      border: 1px solid #00ff00;
      border-radius: 4px;
      font-size: 10px;
      white-space: nowrap;
      max-width: 400px;
      min-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      z-index: 1000;
      transition: opacity 0.3s, visibility 0.3s;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
    }

    .node-count:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }

    .tooltip-address {
      display: block;
      font-family: 'Share Tech Mono', monospace;
      color: #00ffff;
      margin-bottom: 2px;
      white-space: normal;
      word-break: break-all;
      line-height: 1.2;
    }

    .tooltip-address:last-child {
      margin-bottom: 0;
    }

    .chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 10px 20px;
      background: #000;
      min-height: 0;
      -webkit-overflow-scrolling: touch;
    }

    /* Mobile optimizations */
    @media (max-width: 768px) {
      .header {
        padding: 6px 15px;
        min-height: auto;
      }

      .title {
        font-size: 12px;
        flex: 1;
        text-align: left;
      }

      .user-info {
        gap: 8px;
        flex-shrink: 0;
      }

      .nickname-input {
        width: 80px;
        padding: 3px 6px;
        font-size: 11px;
      }

      .status-group {
        align-items: flex-end;
        gap: 1px;
      }

      .status {
        font-size: 9px;
      }

      .node-count {
        font-size: 8px;
      }

      .chat-container {
        padding: 8px 15px;
        padding-bottom: calc(80px + env(safe-area-inset-bottom, 0px)); /* Account for input + safe area */
      }

      .input-container {
        padding: 10px 15px;
        padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        z-index: 1000;
      }

      .message-input {
        font-size: 16px; /* Prevents zoom on iOS */
        padding: 12px 15px;
      }

      .send-button {
        padding: 12px 15px;
        font-size: 14px;
      }

      .message {
        margin-bottom: 8px;
        font-size: 13px;
      }

      .message-status {
        font-size: 11px;
        min-width: 14px;
        height: 14px;
      }

      .sds-id {
        font-size: 7px;
      }

      .source-label {
        font-size: 8px;
      }
    }

    /* Very small screens */
    @media (max-width: 480px) {
      .input-container {
        flex-direction: column;
        gap: 8px;
      }

      .send-button {
        width: 100%;
      }

      .node-count .tooltip {
        right: 0;
        left: auto;
        max-width: calc(100vw - 40px);
      }
    }

    .message {
      margin-bottom: 5px;
      line-height: 1.4;
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }

    .message-content {
      flex: 1;
    }

    .message-status {
      font-size: 12px;
      min-width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
    }

    .message-status.sending {
      color: #ffff00;
      animation: spin 1s linear infinite;
    }

    .message-status.sent {
      color: #00ff00;
    }

    .message-status.acknowledged {
      color: #00ff00;
    }

    .tick {
      display: inline-block;
      font-size: 10px;
    }

    .tick.second {
      margin-left: 1px;
    }

    /* Source label styling */
    .source-label {
      position: absolute;
      right: 0;
      top: 0;
      font-size: 9px;
      color: #00ff00;
      opacity: 0.4;
      font-family: 'Share Tech Mono', monospace;
      transition: opacity 0.2s ease;
      pointer-events: none;
      z-index: 1;
      background: rgba(0, 17, 0, 0.8);
      padding: 1px 4px;
      border-radius: 2px;
      border: 1px solid rgba(0, 255, 0, 0.2);
      font-weight: bold;
      white-space: nowrap;
    }

    .message:hover .source-label {
      opacity: 0.9;
      color: #00ff00;
    }

    .message.system-message .source-label {
      display: none;
    }

    .message.historical-message .source-label {
      color: #0088aa;
      opacity: 0.3;
    }

    .message.historical-message:hover .source-label {
      opacity: 0.7;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .message.historical-message {
      opacity: 0.8;
    }

    .message.historical-message .timestamp {
      color: #555;
    }

    .message.historical-message .sender {
      color: #0088aa;
    }

    .message.historical-message .message-text {
      color: #00aa00;
    }

    .timestamp {
      color: #666;
    }

    .sender {
      color: #00ffff;
      font-weight: bold;
    }

    .message-text {
      color: #00ff00;
    }

    .system-message {
      color: #ffff00;
      font-style: italic;
    }

    .input-container {
      background: #001100;
      border-top: 2px solid #00ff00;
      padding: 15px 20px;
      display: flex;
      gap: 10px;
    }

    .message-input {
      flex: 1;
      background: #000;
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 10px 15px;
      font-family: inherit;
      font-size: 14px;
    }

    .message-input:focus {
      outline: none;
      box-shadow: 0 0 10px #00ff00;
    }

    .send-button {
      background: #003300;
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 10px 20px;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.2s;
    }

    .send-button:hover {
      background: #00ff00;
      color: #000;
      box-shadow: 0 0 10px #00ff00;
    }

    .send-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .connecting {
      color: #ffff00;
    }

    .connected {
      color: #00ff00;
    }

    .error {
      color: #ff0000;
    }

    /* Scrollbar styling */
    .chat-container::-webkit-scrollbar {
      width: 8px;
    }

    .chat-container::-webkit-scrollbar-track {
      background: #001100;
    }

    .chat-container::-webkit-scrollbar-thumb {
      background: #00ff00;
      border-radius: 4px;
    }

    .chat-container::-webkit-scrollbar-thumb:hover {
      background: #00cc00;
    }
  </style>
</head>
<body>
<div class="app-container">
  <div class="header">
    <div class="title">RetroChat • SDS</div>
    <div class="user-info">
      <input type="text" class="nickname-input" placeholder="Enter nickname...">
      <div class="status-group">
        <span class="status connecting" id="status">Connecting...</span>
        <span class="node-count" id="nodeCount">
          Nodes: 0
          <div class="tooltip" id="nodeTooltip">No connections</div>
        </span>
      </div>
    </div>
  </div>

  <div class="chat-container" id="chatContainer">
    <div class="message system-message">
      [SYSTEM] Welcome to RetroChat with SDS reliability! Connecting to Waku network...
    </div>
  </div>

  <div class="input-container">
    <input type="text" class="message-input" id="messageInput" placeholder="Type your message..." disabled>
    <button class="send-button" id="sendButton" disabled>SEND</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/protobufjs@7.5.3/dist/protobuf.min.js"></script>
<script type="module">
  import { createLightNode } from 'https://unpkg.com/@waku/sdk@0.0.34-0be4861.0/bundle/index.js';
  import { MessageChannel, MessageChannelEvent, encodeMessage, decodeMessage } from 'https://unpkg.com/@waku/sds@0.0.5/bundle/index.js';

  // Define protobuf schema
  const protoSchema = `
            syntax = "proto3";
            message Chat2Message {
                uint64 timestamp = 1;
                string nick = 2;
                bytes payload = 3;
                uint64 timestampMs = 4;
            }
        `;

  class RetroIRC {
    constructor() {
      this.node = null;
      this.decoder = null;
      this.encoder = null;
      this.contentTopic = '/toy-chat/2/huilong/proto';
      this.nickname = this.generateRandomNickname();
      this.messages = [];
      this.Chat2Message = null;
      this.nodeCount = 0;
      this.pendingMessages = new Map(); // Track pending messages with SDS
      this.messageChannel = null; // SDS Message Channel
      this.displayedMessages = new Set(); // Track displayed SDS message IDs to prevent dupes
      this.displayedContent = new Set(); // Track displayed content (timestamp+text) to prevent content dupes
      this.isConnectedToStore = false; // Track store node connection

      this.initProtobuf();
      this.initElements();
      this.initEventListeners();
      this.initSDS();
      this.initWaku();
    }

    generateRandomNickname() {
      const adjectives = ['Cool', 'Fast', 'Cyber', 'Neo', 'Dark', 'Retro', 'Quantum', 'Digital', 'Neon', 'Electric'];
      const nouns = ['Hacker', 'User', 'Coder', 'Rider', 'Ghost', 'Agent', 'Phoenix', 'Ninja', 'Byte', 'Node'];
      const randomAdj = adjectives[Math.floor(Math.random() * adjectives.length)];
      const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
      const randomNum = Math.floor(Math.random() * 999) + 1;
      return `${randomAdj}${randomNoun}${randomNum}`;
    }

    async retrieveMissedMessages(missedHistoryEntries) {
      try {
        console.log(`Retrieving ${missedHistoryEntries.length} missed messages using hash-based queries`);

        for (const historyEntry of missedHistoryEntries) {
          const { messageId, retrievalHint } = historyEntry;

          console.log(`Retrieving missed message: ${messageId}${retrievalHint ? ' with hash' : ' without hash'}`);

          let foundMessage = false;

          // Try hash-based query if retrieval hint is available
          if (retrievalHint) {
            try {
              // Hash-based query - no time range
              for await (const messagesPromises of this.node.store.queryGenerator(
                [this.decoder],
                {
                  messageHashes: [retrievalHint]
                }
              )) {
                const messages = await Promise.all(messagesPromises);

                for (const message of messages) {
                  if (message && message.payload) {
                    try {
                      const retrievedSdsMessage = decodeMessage(message.payload);
                      if (retrievedSdsMessage.messageId === messageId) {
                        console.log(`Successfully retrieved ${messageId} using hash query`);

                        // Mark the message as retrieved via hash query before feeding to SDS
                        retrievedSdsMessage._retrievalSource = 'store - sds';

                        // Feed the retrieved message back to SDS
                        this.messageChannel.receiveMessage(retrievedSdsMessage);
                        foundMessage = true;
                        break;
                      }
                    } catch (decodeError) {
                      console.warn('Failed to decode retrieved message:', decodeError);
                    }
                  }
                }

                if (foundMessage) break;
              }
            } catch (hashQueryError) {
              console.warn(`Hash query failed for ${messageId}:`, hashQueryError);
            }
          }

          if (!foundMessage) {
            console.warn(`Could not retrieve missed message: ${messageId} (no valid hash or hash query failed)`);
          }
        }

        // Process any newly received messages
        await this.messageChannel.processTasks();

        this.addSystemMessage(`Completed hash-based retrieval for missed messages`);

      } catch (error) {
        console.error('Failed to retrieve missed messages:', error);
        this.addSystemMessage(`Failed to retrieve missed messages: ${error.message}`);
      }
    }

    async loadMessageHistory() {
      try {
        // Only proceed if we're connected to a store node
        if (!this.isConnectedToStore) {
          console.log('Not connected to store node, skipping message history loading');
          return;
        }

        console.log('Starting progressive message history loading...');

        const now = new Date();
        let historicalMessages = [];
        let messageCount = 0;
        let foundSDSMessage = false;
        let firstSDSMessage = null;

        // Progressive hourly queries up to 24 hours or until we find an SDS message
        for (let hoursBack = 1; hoursBack <= 24 && !foundSDSMessage; hoursBack++) {
          const endTime = new Date(now.getTime() - ((hoursBack - 1) * 60 * 60 * 1000));
          const startTime = new Date(now.getTime() - (hoursBack * 60 * 60 * 1000));

          console.log(`Querying hour ${hoursBack}: ${startTime.toISOString()} to ${endTime.toISOString()}`);

          try {
            // Query the store for messages in this hour
            for await (const messagesPromises of this.node.store.queryGenerator(
              [this.decoder],
              {
                timeStart: startTime,
                timeEnd: endTime
              }
            )) {
              // Process each batch of messages
              const messages = await Promise.all(messagesPromises);

              for (const message of messages) {
                if (message && message.payload) {
                  try {
                    // Try to decode as SDS message
                    const sdsMessage = decodeMessage(message.payload);

                    if (sdsMessage.content && sdsMessage.content.length > 0) {
                      this.messageChannel.receiveMessage(sdsMessage);

                      // Found a valid SDS message!
                      foundSDSMessage = true;
                      if (!firstSDSMessage) {
                        firstSDSMessage = sdsMessage;
                        console.log('Found first SDS message, switching to retrieval hint mode');
                      }

                      // Decode the chat message from SDS content
                      const decodedMessage = this.Chat2Message.decode(sdsMessage.content);

                      const chatMessage = {
                        timestamp: Number(decodedMessage.timestamp) * 1000,
                        sender: decodedMessage.nick,
                        text: new TextDecoder().decode(decodedMessage.payload),
                        sdsMessageId: sdsMessage.messageId || undefined,
                        source: 'store - time'
                      };

                      historicalMessages.push(chatMessage);
                      messageCount++;
                    }
                  } catch (error) {
                    console.warn('Could not decode message as SDS:', error);
                  }
                }
              }
            }

            // If we found SDS messages in this hour, break the loop
            if (foundSDSMessage) {
              console.log(`Found SDS messages in hour ${hoursBack}, stopping progressive search`);
              break;
            }

          } catch (storeError) {
            console.warn(`Store query failed for hour ${hoursBack}:`, storeError);
            // Stop on store error
            break;
          }
        }

        // If we found SDS messages, use retrieval hints for more efficient querying
        if (foundSDSMessage && firstSDSMessage) {
          console.log('Using SDS retrieval hints for additional message history...');

          try {
            // Use SDS message channel to get missed messages with retrieval hints
            const missingMessages = this.messageChannel.sweepIncomingBuffer();
            if (missingMessages.length > 0) {
              console.log(`Found ${missingMessages.length} missing messages via SDS sweep`);

              // Query store using retrieval hints for missing messages
              for (const missingMessageId of missingMessages) {
                try {
                  // Query with broader time range since we have SDS context
                  const extendedStartTime = new Date(now.getTime() - (24 * 60 * 60 * 1000));

                  for await (const messagesPromises of this.node.store.queryGenerator(
                    [this.decoder],
                    {
                      timeStart: extendedStartTime,
                      timeEnd: now
                    }
                  )) {
                    const messages = await Promise.all(messagesPromises);

                    for (const message of messages) {
                      if (message && message.payload) {
                        try {
                          const sdsMessage = decodeMessage(message.payload);
                          if (sdsMessage.messageId === missingMessageId && sdsMessage.content && sdsMessage.content.length > 0) {
                            const decodedMessage = this.Chat2Message.decode(sdsMessage.content);

                            const chatMessage = {
                              timestamp: Number(decodedMessage.timestamp) * 1000,
                              sender: decodedMessage.nick,
                              text: new TextDecoder().decode(decodedMessage.payload),
                              sdsMessageId: sdsMessage.messageId
                            };

                            // Check if we already have this message
                            const exists = historicalMessages.some(msg => msg.sdsMessageId === sdsMessage.messageId);
                            if (!exists) {
                              historicalMessages.push(chatMessage);
                              messageCount++;
                            }
                          }
                        } catch (error) {
                          console.warn('Error processing message with retrieval hint:', error);
                        }
                      }
                    }
                  }
                } catch (retrievalError) {
                  console.warn('Failed to retrieve message with hint:', retrievalError);
                }
              }
            }
          } catch (sdsError) {
            console.warn('SDS retrieval hint query failed:', sdsError);
          }
        }

        // Sort messages by SDS order (lamport timestamp, then by message ID for deterministic ordering)
        historicalMessages.sort((a, b) => {
          if (a.lamportTimestamp !== b.lamportTimestamp) {
            return a.lamportTimestamp - b.lamportTimestamp;
          }
          return a.sdsMessageId.localeCompare(b.sdsMessageId);
        });

        if (messageCount > 0) {
          // Display historical messages and mark as displayed
          for (const message of historicalMessages) {
            const contentKey = `${message.timestampMs}-${message.sender}-${message.text}`;
            this.addChatMessage(message);
            this.displayedMessages.add(message.sdsMessageId);
            this.displayedContent.add(contentKey);
          }

          // Add a subtle system message to indicate history was loaded
          this.addSystemMessage(`Loaded ${messageCount} messages from network history (${foundSDSMessage ? 'with SDS' : 'legacy mode'})`);
          console.log(`Loaded ${messageCount} historical messages`);
        } else {
          console.log('No historical messages found');
        }

      } catch (error) {
        console.error('Failed to load message history:', error);
        this.addSystemMessage(`Failed to load message history: ${error.message}`);
      }
    }

    initProtobuf() {
      const root = window.protobuf.parse(protoSchema).root;
      this.Chat2Message = root.lookupType('Chat2Message');
    }

    initSDS() {
      // Initialize SDS Message Channel with causal history size of 100
      this.messageChannel = new MessageChannel('retro-chat', { causalHistorySize: 100 });

      // Listen for SDS events
      this.messageChannel.addEventListener(MessageChannelEvent.MessageSent, (event) => {
        console.log('SDS: Message sent', event.detail);
      });

      this.messageChannel.addEventListener(MessageChannelEvent.MessageDelivered, (event) => {
        console.log('SDS: Message delivered', event.detail);
      });

      this.messageChannel.addEventListener(MessageChannelEvent.MessageReceived, (event) => {
        console.log('SDS: Message received event triggered', event.detail);
        // Process the received message immediately
        this.handleSDSMessage(event.detail);
      });

      this.messageChannel.addEventListener(MessageChannelEvent.MessageAcknowledged, (event) => {
        console.log('SDS: Message acknowledged', event.detail);
        this.updateMessageStatusBySDSId(event.detail, 'acknowledged');
      });

      this.messageChannel.addEventListener(MessageChannelEvent.PartialAcknowledgement, (event) => {
        console.log('SDS: Partial acknowledgement', event.detail);
      });

      this.messageChannel.addEventListener(MessageChannelEvent.MissedMessages, async (event) => {
        if (event.detail.length > 0) {
          console.log('SDS: Missed messages detected', event.detail);
          this.addSystemMessage(`SDS: Detected ${event.detail.length} missed messages, retrieving...`);

          // Retrieve missed messages using hash-based queries
          await this.retrieveMissedMessages(event.detail);
        }
      });

      // Process SDS tasks regularly and handle message sweeping
      setInterval(async () => {
        try {
          await this.messageChannel.processTasks();

          // Sweep incoming buffer to check for deliverable messages
          const missingMessages = this.messageChannel.sweepIncomingBuffer();
          if (missingMessages.length > 0) {
            console.log('SDS: Missing messages detected:', missingMessages.length);
          }
        } catch (error) {
          console.error('Error processing SDS tasks:', error);
        }
      }, 1000);

      // Send sync messages every 30 seconds
      setInterval(async () => {
        if (this.node && this.status.classList.contains('connected')) {
          try {
            await this.messageChannel.sendSyncMessage(async (syncMessage) => {
              // Send sync message via Waku
              await this.node.lightPush.send(this.encoder, {
                payload: encodeMessage(syncMessage)
              });
              return true;
            });
            console.log('SDS: Sent sync message');
          } catch (error) {
            console.error('Failed to send sync message:', error);
          }
        }
      }, 30000); // Every 30 seconds
    }

    initElements() {
      this.chatContainer = document.getElementById('chatContainer');
      this.messageInput = document.getElementById('messageInput');
      this.sendButton = document.getElementById('sendButton');
      this.nicknameInput = document.querySelector('.nickname-input');
      this.status = document.getElementById('status');
      this.nodeCount = document.getElementById('nodeCount');
      this.nodeTooltip = document.getElementById('nodeTooltip');

      // Set the random nickname in the input field
      this.nicknameInput.value = this.nickname;
    }

    initEventListeners() {
      this.sendButton.addEventListener('click', () => this.sendMessage());

      // Handle Enter key for sending messages
      this.messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.sendMessage();
        }
      });

      this.nicknameInput.addEventListener('change', (e) => {
        this.nickname = e.target.value.trim() || this.generateRandomNickname();
        this.addSystemMessage(`Nickname changed to: ${this.nickname}`);
      });

      // Also handle Enter for nickname input
      this.nicknameInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          this.nickname = e.target.value.trim() || this.generateRandomNickname();
          this.addSystemMessage(`Nickname changed to: ${this.nickname}`);
          this.messageInput.focus(); // Focus back to message input
        }
      });
    }

    async initWaku() {
      try {
        this.updateStatus('Connecting...', 'connecting');
        this.updateNodeCount(0);

        // Create Waku node
        this.node = await createLightNode({ defaultBootstrap: true });

        // Listen for connection events using Waku event system
        this.node.events.addEventListener("waku:connection", (event) => {
          console.log('Waku connection event:', event.detail); // true if connected, false if disconnected
          this.checkStoreConnection();
        });

        await this.node.start();

        // Dial the specific node
        const multiAddrWithId = '/dns4/waku.fryorcraken.xyz/tcp/8000/wss/p2p/16Uiu2HAmMRvhDHrtiHft1FTUYnn6cVA8AWVrTyLUayJJ3MWpUZDB';
        try {
          await this.node.dial(multiAddrWithId);
          console.log('Successfully dialed custom Waku node');
        } catch (dialError) {
          console.warn('Failed to dial custom node:', dialError);
        }

        this.updateStatus('Waiting for peers...', 'connecting');

        // Create encoder and decoder
        this.encoder = this.node.createEncoder({ contentTopic: this.contentTopic });
        this.decoder = this.node.createDecoder({ contentTopic: this.contentTopic });

        // Subscribe to messages (don't wait for specific protocol peers)
        await this.node.filter.subscribe([this.decoder], (message) => {
          this.handleIncomingWakuMessage(message);
        });

        // Enable sending immediately
        this.messageInput.disabled = false;
        this.sendButton.disabled = false;

        this.updateStatus('Connected', 'connected');

        // Start monitoring node connections
        this.startNodeCountMonitoring();
        this.startStoreMonitoring();

        this.addSystemMessage('Connected to Waku network! Waiting for store nodes to load history...');

      } catch (error) {
        console.error('Failed to initialize Waku:', error);
        this.updateStatus('Connection failed', 'error');
        this.addSystemMessage(`Connection failed: ${error.message}`);
      }
    }

    async checkStoreConnection() {
      if (!this.node) return;

      try {
        // Get all connected peers with their protocol support
        const connectedPeers = await this.node.getConnectedPeers();

        // Find peers that support the store protocol
        const storePeers = connectedPeers.filter(peerInfo =>
          peerInfo.protocols && peerInfo.protocols.includes('/vac/waku/store/2.0.0-beta4')
        );

        const hasStore = storePeers.length > 0;

        console.log(`Connected peers: ${connectedPeers.length}, Store peers: ${storePeers.length}`);
        if (storePeers.length > 0) {
          console.log('Store peers:', storePeers.map(p => p.id.toString()));
        }

        // Track connection state changes
        const wasConnectedToStore = this.isConnectedToStore;
        this.isConnectedToStore = hasStore;

        // Start store queries when we first connect to a store node
        if (!wasConnectedToStore && hasStore) {
          console.log('Connected to store node, starting message history loading...');
          this.addSystemMessage('Store node connected, loading message history...');
          await this.loadMessageHistory();
        } else if (wasConnectedToStore && !hasStore) {
          console.log('Lost connection to store nodes');
          this.addSystemMessage('Lost connection to store nodes - history loading unavailable');
        }

      } catch (error) {
        console.error('Failed to check store connection:', error);
      }
    }

    startStoreMonitoring() {
      // Check store connection every 5 seconds
      setInterval(() => {
        this.checkStoreConnection();
      }, 5000);
    }

    startNodeCountMonitoring() {
      // Update node count immediately and then every 5 seconds
      this.updateNodeCountFromWaku();
      setInterval(() => {
        this.updateNodeCountFromWaku();
      }, 5000);
    }

    async updateNodeCountFromWaku() {
      if (this.node && this.node.libp2p && this.node.libp2p.getConnections) {
        try {
          const connections = this.node.libp2p.getConnections();
          const activeConnections = connections.filter(conn => conn.status === 'open');
          const connectedPeers = activeConnections.length;

          // Get peer addresses for tooltip and extract domain names
          const peerAddresses = activeConnections.map(conn => {
            const remoteAddr = conn.remoteAddr;
            if (remoteAddr) {
              const addrString = remoteAddr.toString();
              return this.extractDomainFromAddress(addrString);
            }
            return 'Unknown address';
          });

          this.updateNodeCount(connectedPeers, peerAddresses);
        } catch (error) {
          // Fallback if getConnections method doesn't exist or fails
          console.warn('Could not get connection count:', error);
          this.updateNodeCount(0, []);
        }
      }
    }

    extractDomainFromAddress(address) {
      try {
        // Handle different multiaddr formats
        // Examples:
        // /dns4/node-01.do-ams3.waku.test/tcp/8000/ws/p2p/16Uiu2...
        // /ip4/127.0.0.1/tcp/60001/ws/p2p/16Uiu2...
        // /dns/bootstrap.libp2p.io/tcp/443/wss/p2p/QmNnooDu7...

        const parts = address.split('/');

        // Look for dns4, dns6, or dns parts
        for (let i = 0; i < parts.length - 1; i++) {
          if (parts[i] === 'dns4' || parts[i] === 'dns6' || parts[i] === 'dns') {
            return parts[i + 1];
          }
        }

        // If no domain found, look for IP address
        for (let i = 0; i < parts.length - 1; i++) {
          if (parts[i] === 'ip4' || parts[i] === 'ip6') {
            return parts[i + 1];
          }
        }

        // Fallback: return the original address if we can't parse it
        return address;
      } catch (error) {
        return address;
      }
    }

    updateStatus(text, className) {
      this.status.textContent = text;
      this.status.className = `status ${className}`;
    }

    updateNodeCount(count, addresses = []) {
      const nodeCountSpan = this.nodeCount.firstChild;
      nodeCountSpan.textContent = `Nodes: ${count}`;

      // Update tooltip content
      if (count === 0) {
        this.nodeTooltip.textContent = 'No connections';
      } else {
        this.nodeTooltip.innerHTML = addresses
          .map(addr => `<span class="tooltip-address">${this.escapeHtml(addr)}</span>`)
          .join('');
      }
    }

    async sendMessage() {
      const text = this.messageInput.value.trim();
      if (!text || !this.node || !this.Chat2Message) return;

      // Disable input temporarily
      this.messageInput.disabled = true;
      this.sendButton.disabled = true;

      // Clear input immediately
      const originalText = text;
      this.messageInput.value = '';

      // Create a temporary message ID for tracking
      const messageId = Date.now() + '-' + Math.random();

      try {
        // Create protobuf message
        const chatMessage = {
          timestamp: Math.floor(Date.now() / 1000), // Unix timestamp in seconds
          nick: this.nickname,
          payload: new TextEncoder().encode(originalText),
          timestampMs: Date.now() // Timestamp in milliseconds
        };

        // Encode with protobuf
        const protoMessage = this.Chat2Message.create(chatMessage);
        const payload = this.Chat2Message.encode(protoMessage).finish();

        // Add the message to chat with sending status
        const messageElement = this.addChatMessageWithStatus({
          timestamp: Date.now(),
          sender: this.nickname,
          text: originalText,
          messageId: messageId,
          status: 'sending'
        });

        // Send through SDS for reliability
        await this.messageChannel.sendMessage(payload, async (sdsMessage) => {
          try {
            // Mark the SDS message as sent by local app
            sdsMessage._retrievalSource = 'sent';

            // Create Waku message with SDS wrapper (causal history automatically included by SDS)
            const wakuMessage = { payload: encodeMessage(sdsMessage) };

            // Send via Waku LightPush
            const result = await this.node.lightPush.send(this.encoder, wakuMessage);

            // Update message status to sent and track SDS message ID
            this.updateMessageStatus(messageId, 'sent');
            this.pendingMessages.set(sdsMessage.messageId, messageId);

            // Update the SDS ID in the message element
            this.updateMessageSDSId(messageId, sdsMessage.messageId);

            // Return success with message hash as retrieval hint
            // The message hash can be used later to query the store directly
            return {
              success: true,
              retrievalHint: this.node.store.createCursor(wakuMessage)
            };
          } catch (error) {
            console.error('Failed to send via Waku:', error);
            return { success: false };
          }
        });

      } catch (error) {
        console.error('Failed to send message:', error);
        this.addSystemMessage(`Failed to send message: ${error.message}`);
        // Restore the message on error
        this.messageInput.value = originalText;
      } finally {
        // Re-enable input
        this.messageInput.disabled = false;
        this.sendButton.disabled = false;
        this.messageInput.focus();
      }
    }

    async handleIncomingWakuMessage(wakuMessage) {
      try {
        if (!wakuMessage.payload) {
          console.log('Waku: Received message with no payload');
          return;
        }

        console.log('Waku: Received message, payload length:', wakuMessage.payload.length);

        // Decode SDS message
        const sdsMessage = decodeMessage(wakuMessage.payload);
        console.log('Waku: Decoded SDS message:', sdsMessage);

        // Process through SDS message channel first
        this.messageChannel.receiveMessage(sdsMessage);

        // Use SDS sweepIncomingBuffer to detect missing messages
        const missingMessageIds = this.messageChannel.sweepIncomingBuffer();

        if (missingMessageIds.length > 0) {
          console.log(`SDS detected ${missingMessageIds.length} missing messages from sweep`);
          // Note: Don't call retrieveMissedMessages here - let the MissedMessages event handle it
        }

        // Process SDS tasks immediately to handle the received message
        await this.messageChannel.processTasks();
        console.log('Waku: Processed SDS tasks');

      } catch (error) {
        console.error('Failed to process incoming Waku message (SDS only):', error);
      }
    }

    async retrieveMissedMessagesFromCausalHistory(currentMessage, missingMessageIds) {
      try {
        // Use causal history from the current message to find retrieval hints
        const causalHistory = currentMessage.causalHistory || [];
        console.log(`Processing causal history with ${causalHistory.length} entries for ${missingMessageIds.length} missing messages`);

        for (const missingMessageId of missingMessageIds) {
          // Find retrieval hint for this missing message in causal history
          const historyEntry = causalHistory.find(entry => entry.messageId === missingMessageId);
          const retrievalHint = historyEntry?.retrievalHint;

          console.log(`Retrieving missing message: ${missingMessageId}${retrievalHint ? ' with hint' : ' without hint'}`);

          let foundMessage = false;

          // Try retrieval hint first if available (hash-based query)
          if (retrievalHint) {
            try {
              // Hash-based query - no time range
              for await (const messagesPromises of this.node.store.queryGenerator(
                [this.decoder],
                {
                  messageHashes: [retrievalHint]
                }
              )) {
                const messages = await Promise.all(messagesPromises);

                for (const message of messages) {
                  if (message && message.payload) {
                    try {
                      const retrievedSdsMessage = decodeMessage(message.payload);
                      if (retrievedSdsMessage.messageId === missingMessageId) {
                        console.log(`Successfully retrieved ${missingMessageId} using hash query`);

                        // Feed the retrieved message back to SDS
                        this.messageChannel.receiveMessage(retrievedSdsMessage);
                        foundMessage = true;
                        break;
                      }
                    } catch (decodeError) {
                      console.warn('Failed to decode retrieved message:', decodeError);
                    }
                  }
                }

                if (foundMessage) break;
              }
            } catch (hintQueryError) {
              console.warn(`Hash query failed for ${missingMessageId}:`, hintQueryError);
            }
          }

          // No fallback to time-based search - hash queries only
          if (!foundMessage) {
            console.warn(`Could not retrieve missing message: ${missingMessageId} (no valid hash or hash query failed)`);
          }
        }

        this.addSystemMessage(`Completed hash-based retrieval for missing messages`);

      } catch (error) {
        console.error('Failed to retrieve missed messages from causal history:', error);
      }
    }

    handleSDSMessage(sdsMessage) {
      try {
        if (!sdsMessage.content || sdsMessage.content.length === 0) {
          // This is a sync message, ignore for chat display
          console.log('SDS: Received sync message, ignoring for chat display');
          return;
        }

        console.log('SDS: Processing message with content length:', sdsMessage.content.length);
        console.log('SDS: Full message object:', sdsMessage);

        // Check for SDS ID duplicate - skip if already displayed
        if (this.displayedMessages.has(sdsMessage.messageId)) {
          console.log('SDS: Skipping duplicate message by SDS ID:', sdsMessage.messageId);
          return;
        }

        // Decode the chat message from SDS content
        const decodedMessage = this.Chat2Message.decode(sdsMessage.content);

        const message = {
          timestamp: Number(decodedMessage.timestamp) * 1000,
          timestampMs: Number(decodedMessage.timestampMs) || (Number(decodedMessage.timestamp) * 1000), // Use timestampMs if available, fallback to timestamp
          sender: decodedMessage.nick,
          text: new TextDecoder().decode(decodedMessage.payload),
          sdsMessageId: sdsMessage.messageId || 'unknown',
          lamportTimestamp: sdsMessage.lamportTimestamp || 0,
          source: sdsMessage._retrievalSource || 'filter' // Use marked source or default to filter
        };

        // Create content fingerprint using timestampMs for more precise duplicate detection
        const contentKey = `${message.timestampMs}-${message.sender}-${message.text}`;

        // Check for content duplicate - skip if same timestamp+sender+text already displayed
        if (this.displayedContent.has(contentKey)) {
          console.log('SDS: Skipping duplicate message by content:', contentKey);
          return;
        }

        console.log('SDS: Decoded message from', message.sender, ':', message.text, 'SDS ID:', message.sdsMessageId);

        // Only add if it's not from ourselves (to avoid duplicates) and not already displayed
        if (message.sender !== this.nickname) {
          this.addChatMessage(message);
          this.displayedMessages.add(message.sdsMessageId);
          this.displayedContent.add(contentKey);
          console.log('SDS: Added message to chat from', message.sender, 'with SDS ID:', message.sdsMessageId);
        } else {
          console.log('SDS: Ignoring own message');
        }

      } catch (error) {
        console.error('Failed to process SDS message:', error);
      }
    }

    storeSDSMessage(sdsMessage) {
      try {
        console.log('SDS: Storing message:', sdsMessage.messageId);

        // Decode the chat message from SDS content
        const decodedMessage = this.Chat2Message.decode(sdsMessage.content);

        const message = {
          timestamp: Number(decodedMessage.timestamp) * 1000,
          sender: decodedMessage.nick,
          text: new TextDecoder().decode(decodedMessage.payload),
          sdsMessageId: sdsMessage.messageId || 'unknown',
          lamportTimestamp: sdsMessage.lamportTimestamp || 0,
          sdsMessage: sdsMessage
        };

        // Store the message (this will overwrite duplicates)
        this.allMessages.set(sdsMessage.messageId, message);

      } catch (error) {
        console.error('Failed to store SDS message:', error);
      }
    }

    refreshMessageDisplay() {
      try {
        // Get all deliverable messages from SDS in proper order
        const deliverableMessages = [];

        // Get all stored messages and check which ones SDS says are deliverable
        for (const [messageId, message] of this.allMessages.entries()) {
          // Skip our own messages to avoid duplicates
          if (message.sender === this.nickname) {
            continue;
          }

          // Only display if not already displayed
          if (!this.displayedMessages.has(messageId)) {
            deliverableMessages.push(message);
          }
        }

        // Sort by lamport timestamp for SDS ordering
        deliverableMessages.sort((a, b) => {
          if (a.lamportTimestamp !== b.lamportTimestamp) {
            return a.lamportTimestamp - b.lamportTimestamp;
          }
          return a.sdsMessageId.localeCompare(b.sdsMessageId);
        });

        // Display new messages
        for (const message of deliverableMessages) {
          if (!this.displayedMessages.has(message.sdsMessageId)) {
            this.addChatMessage(message);
            this.displayedMessages.add(message.sdsMessageId);
            console.log('Displayed message:', message.sdsMessageId, 'from', message.sender);
          }
        }

      } catch (error) {
        console.error('Failed to refresh message display:', error);
      }
    }

    updateMessageStatusBySDSId(sdsMessageId, status) {
      const messageId = this.pendingMessages.get(sdsMessageId);
      if (messageId) {
        this.updateMessageStatus(messageId, status);
        if (status === 'acknowledged') {
          // Remove from pending messages once acknowledged
          this.pendingMessages.delete(sdsMessageId);
        }
      }
    }

    addChatMessage(message) {
      const messageElement = document.createElement('div');
      messageElement.className = 'message';

      const timestamp = new Date(message.timestamp).toLocaleTimeString();

      console.log('Adding chat message with source:', message.source);

      messageElement.innerHTML = `
        <div class="message-content">
          <span class="timestamp">[${timestamp}]</span>
          <span class="sender">&lt;${this.escapeHtml(message.sender)}&gt;</span>
          <span class="message-text"> ${this.escapeHtml(message.text)}</span>
        </div>
        <div class="source-label" title="Message source: ${message.source}">${message.source}</div>
      `;

      this.chatContainer.appendChild(messageElement);
      this.scrollToBottom();

      return messageElement;
    }

    addHistoricalChatMessage(message) {
      const messageElement = document.createElement('div');
      messageElement.className = 'message historical-message';

      const timestamp = new Date(message.timestamp).toLocaleTimeString();
      const date = new Date(message.timestamp).toLocaleDateString();
      const sdsId = message.sdsMessageId ? this.truncateSDSId(message.sdsMessageId) : 'hist-id';

      console.log('Adding historical message with SDS ID:', message.sdsMessageId, 'truncated to:', sdsId);

      messageElement.innerHTML = `
        <div class="message-content">
          <span class="timestamp">[${date} ${timestamp}]</span>
          <span class="sender">&lt;${this.escapeHtml(message.sender)}&gt;</span>
          <span class="message-text"> ${this.escapeHtml(message.text)}</span>
        </div>
        <div class="sds-id" title="SDS ID: ${message.sdsMessageId || 'Historical message'}">${sdsId}</div>
      `;

      this.chatContainer.appendChild(messageElement);

      return messageElement;
    }

    addChatMessageWithStatus(message) {
      const messageElement = document.createElement('div');
      messageElement.className = 'message';
      messageElement.dataset.messageId = message.messageId;

      const timestamp = new Date(message.timestamp).toLocaleTimeString();

      const statusIcon = this.getStatusIcon(message.status);
      const statusClass = message.status;

      messageElement.innerHTML = `
        <div class="message-content">
          <span class="timestamp">[${timestamp}]</span>
          <span class="sender">&lt;${message.sender}&gt;</span>
          <span class="message-text"> ${this.escapeHtml(message.text)}</span>
        </div>
        <div class="message-status ${statusClass}">${statusIcon}</div>
        <div class="sds-id" title="SDS ID will appear after sending">...</div>
      `;

      this.chatContainer.appendChild(messageElement);
      this.scrollToBottom();

      return messageElement;
    }

    getStatusIcon(status) {
      switch (status) {
        case 'sending':
          return '◐';
        case 'sent':
          return '<span class="tick">✓</span>';
        case 'acknowledged':
          return '<span class="tick">✓</span><span class="tick second">✓</span>';
        default:
          return '◐';
      }
    }

    updateMessageStatus(messageId, status) {
      const messageElement = this.chatContainer.querySelector(`[data-message-id="${messageId}"]`);
      if (messageElement) {
        const statusElement = messageElement.querySelector('.message-status');
        if (statusElement) {
          statusElement.className = `message-status ${status}`;
          statusElement.innerHTML = this.getStatusIcon(status);
        }
      }
    }

    updateMessageSDSId(messageId, sdsMessageId) {
      // This function is no longer needed since we're using source labels instead of SDS IDs
      // Keep it for compatibility but make it a no-op
      console.log('updateMessageSDSId called but using source labels instead');
    }

    truncateSDSId(sdsMessageId) {
      // Show first 6 characters of SDS message ID for discreteness
      if (!sdsMessageId) return 'no-id';
      return sdsMessageId.length > 6 ? sdsMessageId.substring(0, 6) + '...' : sdsMessageId;
    }

    addSystemMessage(text) {
      const messageElement = document.createElement('div');
      messageElement.className = 'message system-message';
      messageElement.innerHTML = `
        <div class="message-content">[SYSTEM] ${text}</div>
      `;

      this.chatContainer.appendChild(messageElement);
      this.scrollToBottom();
    }

    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    scrollToBottom() {
      // Use requestAnimationFrame to ensure DOM is updated before scrolling
      requestAnimationFrame(() => {
        this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
      });
    }
  }

  // Initialize the chat application
  window.addEventListener('DOMContentLoaded', () => {
    new RetroIRC();
  });
</script>
</body>
</html>
