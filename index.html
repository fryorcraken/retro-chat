<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RetroChat - IRC Style with SDS</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono:wght@400&display=swap');

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Share Tech Mono', monospace;
      background: #000;
      color: #00ff00;
      min-height: 100vh;
      height: 100%;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    @supports (-webkit-touch-callout: none) {
      body {
        min-height: -webkit-fill-available;
      }
    }

    .header {
      background: #001100;
      border-bottom: 2px solid #00ff00;
      padding: 10px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      position: sticky;
      top: 0;
      z-index: 1000;
      flex-shrink: 0;
    }

    .title {
      font-size: 18px;
      color: #00ff00;
      text-shadow: 0 0 10px #00ff00;
    }

    .user-info {
      display: flex;
      align-items: center;
      gap: 15px;
    }

    .nickname-input {
      background: #000;
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 5px 10px;
      font-family: inherit;
      font-size: 14px;
    }

    .nickname-input:focus {
      outline: none;
      box-shadow: 0 0 5px #00ff00;
    }

    .status-group {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 2px;
    }

    .status {
      color: #ffff00;
      font-size: 12px;
    }

    .node-count {
      color: #00ffff;
      font-size: 11px;
      cursor: help;
      position: relative;
    }

    .node-count .tooltip {
      visibility: hidden;
      opacity: 0;
      position: absolute;
      top: 100%;
      right: 0;
      margin-top: 5px;
      background: #001100;
      color: #00ff00;
      padding: 8px 12px;
      border: 1px solid #00ff00;
      border-radius: 4px;
      font-size: 10px;
      white-space: nowrap;
      max-width: 400px;
      min-width: 200px;
      overflow: hidden;
      text-overflow: ellipsis;
      z-index: 1000;
      transition: opacity 0.3s, visibility 0.3s;
      box-shadow: 0 0 10px rgba(0, 255, 0, 0.3);
    }

    .node-count:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }

    .tooltip-address {
      display: block;
      font-family: 'Share Tech Mono', monospace;
      color: #00ffff;
      margin-bottom: 2px;
      white-space: normal;
      word-break: break-all;
      line-height: 1.2;
    }

    .tooltip-address:last-child {
      margin-bottom: 0;
    }

    .chat-container {
      flex: 1;
      overflow-y: auto;
      padding: 10px 20px;
      background: #000;
      min-height: 0;
      -webkit-overflow-scrolling: touch;
    }

    /* Mobile optimizations */
    @media (max-width: 768px) {
      .header {
        padding: 6px 15px;
        min-height: auto;
      }

      .title {
        font-size: 12px;
        flex: 1;
        text-align: left;
      }

      .user-info {
        gap: 8px;
        flex-shrink: 0;
      }

      .nickname-input {
        width: 80px;
        padding: 3px 6px;
        font-size: 11px;
      }

      .status-group {
        align-items: flex-end;
        gap: 1px;
      }

      .status {
        font-size: 9px;
      }

      .node-count {
        font-size: 8px;
      }

      .chat-container {
        padding: 8px 15px;
        padding-bottom: env(safe-area-inset-bottom, 0px);
      }

      .input-container {
        padding: 10px 15px;
        padding-bottom: calc(10px + env(safe-area-inset-bottom, 0px));
        position: relative;
        z-index: 1000;
      }

      .message-input {
        font-size: 16px; /* Prevents zoom on iOS */
        padding: 12px 15px;
      }

      .send-button {
        padding: 12px 15px;
        font-size: 14px;
      }

      .message {
        margin-bottom: 8px;
        font-size: 13px;
      }

      .message-status {
        font-size: 11px;
        min-width: 14px;
        height: 14px;
      }

      .sds-id {
        font-size: 7px;
      }
    }

    /* Very small screens */
    @media (max-width: 480px) {
      .input-container {
        flex-direction: column;
        gap: 8px;
      }

      .send-button {
        width: 100%;
      }

      .node-count .tooltip {
        right: 0;
        left: auto;
        max-width: calc(100vw - 40px);
      }
    }

    .message {
      margin-bottom: 5px;
      line-height: 1.4;
      display: flex;
      align-items: center;
      gap: 8px;
      position: relative;
    }

    .message-content {
      flex: 1;
    }

    .message-status {
      font-size: 12px;
      min-width: 16px;
      height: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 2px;
    }

    .message-status.sending {
      color: #ffff00;
      animation: spin 1s linear infinite;
    }

    .message-status.sent {
      color: #00ff00;
    }

    .message-status.acknowledged {
      color: #00ff00;
    }

    .tick {
      display: inline-block;
      font-size: 10px;
    }

    .tick.second {
      margin-left: 1px;
    }

    /* SDS Message ID styling */
    .sds-id {
      position: absolute;
      right: 0;
      top: 0;
      font-size: 8px;
      color: #00ff00;
      opacity: 0.4;
      font-family: 'Share Tech Mono', monospace;
      transition: opacity 0.2s ease;
      pointer-events: none;
      z-index: 1;
      background: rgba(0, 17, 0, 0.8);
      padding: 1px 3px;
      border-radius: 2px;
      border: 1px solid rgba(0, 255, 0, 0.2);
    }

    .message:hover .sds-id {
      opacity: 0.9;
      color: #00ff00;
    }

    .message.system-message .sds-id {
      display: none;
    }

    .message.historical-message .sds-id {
      color: #0088aa;
      opacity: 0.3;
    }

    .message.historical-message:hover .sds-id {
      opacity: 0.7;
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .message.historical-message {
      opacity: 0.8;
    }

    .message.historical-message .timestamp {
      color: #555;
    }

    .message.historical-message .sender {
      color: #0088aa;
    }

    .message.historical-message .message-text {
      color: #00aa00;
    }

    .timestamp {
      color: #666;
    }

    .sender {
      color: #00ffff;
      font-weight: bold;
    }

    .message-text {
      color: #00ff00;
    }

    .system-message {
      color: #ffff00;
      font-style: italic;
    }

    .input-container {
      background: #001100;
      border-top: 2px solid #00ff00;
      padding: 15px 20px;
      display: flex;
      gap: 10px;
    }

    .message-input {
      flex: 1;
      background: #000;
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 10px 15px;
      font-family: inherit;
      font-size: 14px;
    }

    .message-input:focus {
      outline: none;
      box-shadow: 0 0 10px #00ff00;
    }

    .send-button {
      background: #003300;
      border: 1px solid #00ff00;
      color: #00ff00;
      padding: 10px 20px;
      font-family: inherit;
      cursor: pointer;
      transition: all 0.2s;
    }

    .send-button:hover {
      background: #00ff00;
      color: #000;
      box-shadow: 0 0 10px #00ff00;
    }

    .send-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .connecting {
      color: #ffff00;
    }

    .connected {
      color: #00ff00;
    }

    .error {
      color: #ff0000;
    }

    /* Scrollbar styling */
    .chat-container::-webkit-scrollbar {
      width: 8px;
    }

    .chat-container::-webkit-scrollbar-track {
      background: #001100;
    }

    .chat-container::-webkit-scrollbar-thumb {
      background: #00ff00;
      border-radius: 4px;
    }

    .chat-container::-webkit-scrollbar-thumb:hover {
      background: #00cc00;
    }
  </style>
</head>
<body>
<div class="header">
  <div class="title">RetroChat • SDS</div>
  <div class="user-info">
    <input type="text" class="nickname-input" placeholder="Enter nickname...">
    <div class="status-group">
      <span class="status connecting" id="status">Connecting...</span>
      <span class="node-count" id="nodeCount">
        Nodes: 0
        <div class="tooltip" id="nodeTooltip">No connections</div>
      </span>
    </div>
  </div>
</div>

<div class="chat-container" id="chatContainer">
  <div class="message system-message">
    [SYSTEM] Welcome to RetroChat with SDS reliability! Connecting to Waku network...
  </div>
</div>

<div class="input-container">
  <input type="text" class="message-input" id="messageInput" placeholder="Type your message..." disabled>
  <button class="send-button" id="sendButton" disabled>SEND</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/protobufjs@7.5.3/dist/protobuf.min.js"></script>
<script type="module">
  import { createLightNode, waitForRemotePeer, Protocols } from 'https://unpkg.com/@waku/sdk@0.0.34-86d39d9.0/bundle/index.js';
  import { MessageChannel, MessageChannelEvent, encodeMessage, decodeMessage } from 'https://unpkg.com/@waku/sds@0.0.5/bundle/index.js';

  // Define protobuf schema
  const protoSchema = `
            syntax = "proto3";
            message Chat2Message {
                uint64 timestamp = 1;
                string nick = 2;
                bytes payload = 3;
            }
        `;

  class RetroIRC {
    constructor() {
      this.node = null;
      this.decoder = null;
      this.encoder = null;
      this.contentTopic = '/toy-chat/2/huilong/proto';
      this.nickname = this.generateRandomNickname();
      this.messages = [];
      this.Chat2Message = null;
      this.nodeCount = 0;
      this.pendingMessages = new Map(); // Track pending messages with SDS
      this.messageChannel = null; // SDS Message Channel

      this.initProtobuf();
      this.initElements();
      this.initEventListeners();
      this.initSDS();
      this.initWaku();
    }

    generateRandomNickname() {
      const adjectives = ['Cool', 'Fast', 'Cyber', 'Neo', 'Dark', 'Retro', 'Quantum', 'Digital', 'Neon', 'Electric'];
      const nouns = ['Hacker', 'User', 'Coder', 'Rider', 'Ghost', 'Agent', 'Phoenix', 'Ninja', 'Byte', 'Node'];
      const randomAdj = adjectives[Math.floor(Math.random() * adjectives.length)];
      const randomNoun = nouns[Math.floor(Math.random() * nouns.length)];
      const randomNum = Math.floor(Math.random() * 999) + 1;
      return `${randomAdj}${randomNoun}${randomNum}`;
    }

    async retrieveMissedMessages(missedHistoryEntries) {
      try {
        const missedMessages = [];

        // Query store for each missed message
        for (const historyEntry of missedHistoryEntries) {
          const { messageId, retrievalHint } = historyEntry;

          console.log(`Retrieving missed message: ${messageId}`);

          // Query store using message hash if available
          const messages = [];
          for await (const messagesPromises of this.node.store.queryGenerator(
            [this.decoder],
            {
              messageHashes: retrievalHint ? [retrievalHint] : undefined,
              // If no retrieval hint, query recent messages
              timeStart: retrievalHint ? undefined : new Date(Date.now() - 60 * 60 * 1000), // Last hour
              timeEnd: retrievalHint ? undefined : new Date()
            }
          )) {
            const resolvedMessages = await Promise.all(messagesPromises);
            messages.push(...resolvedMessages.filter(m => m && m.payload));
          }

          // Find the specific missed message by ID
          for (const message of messages) {
            try {
              const sdsMessage = decodeMessage(message.payload);
              if (sdsMessage.messageId === messageId) {
                missedMessages.push(sdsMessage);
                break;
              }
            } catch (error) {
              console.warn('Error decoding message during retrieval:', error);
            }
          }
        }

        // Process retrieved messages
        if (missedMessages.length > 0) {
          this.addSystemMessage(`Retrieved ${missedMessages.length} of ${missedHistoryEntries.length} missed messages`);

          // Sort by timestamp and process
          missedMessages.sort((a, b) => (a.lamportTimestamp || 0) - (b.lamportTimestamp || 0));

          for (const sdsMessage of missedMessages) {
            // Process through SDS to update internal state
            this.messageChannel.receiveMessage(sdsMessage);
            await this.messageChannel.processTasks();
          }
        } else {
          this.addSystemMessage(`Could not retrieve missed messages`);
        }

      } catch (error) {
        console.error('Failed to retrieve missed messages:', error);
        this.addSystemMessage(`Failed to retrieve missed messages: ${error.message}`);
      }
    }

    async loadMessageHistory() {
      try {
        // Calculate time range for past 24 hours
        const now = new Date();
        const twentyFourHoursAgo = new Date(now.getTime() - (24 * 60 * 60 * 1000));

        console.log(`Loading message history from ${twentyFourHoursAgo.toISOString()} to ${now.toISOString()}`);

        let messageCount = 0;
        const historicalMessages = [];

        // Query the store for messages in the past 24 hours
        for await (const messagesPromises of this.node.store.queryGenerator(
          [this.decoder],
          {
            timeStart: twentyFourHoursAgo,
            timeEnd: now
          }
        )) {
          // Process each batch of messages
          const messages = await Promise.all(messagesPromises);

          for (const message of messages) {
            if (message && message.payload) {
              try {
                // Decode as SDS message
                const sdsMessage = decodeMessage(message.payload);

                if (sdsMessage.content && sdsMessage.content.length > 0) {
                  // Decode the chat message from SDS content
                  const decodedMessage = this.Chat2Message.decode(sdsMessage.content);

                  const chatMessage = {
                    timestamp: Number(decodedMessage.timestamp) * 1000,
                    sender: decodedMessage.nick,
                    text: new TextDecoder().decode(decodedMessage.payload),
                    sdsMessageId: sdsMessage.messageId || 'hist-' + Math.random().toString(36).substr(2, 6)
                  };

                  historicalMessages.push(chatMessage);
                  messageCount++;
                }
              } catch (error) {
                console.warn('Could not decode SDS message:', error);
              }
            }
          }
        }

        // Sort messages by timestamp to ensure proper order
        historicalMessages.sort((a, b) => a.timestamp - b.timestamp);

        if (messageCount > 0) {
          // Display historical messages without separators - they should look like live messages
          for (const message of historicalMessages) {
            this.addChatMessage(message);
          }

          // Add a subtle system message to indicate history was loaded
          this.addSystemMessage(`Loaded ${messageCount} messages from network history`);
          console.log(`Loaded ${messageCount} historical messages`);
        } else {
          console.log('No historical messages found');
        }

      } catch (error) {
        console.error('Failed to load message history:', error);
        this.addSystemMessage(`Failed to load message history: ${error.message}`);
      }
    }

    initProtobuf() {
      const root = window.protobuf.parse(protoSchema).root;
      this.Chat2Message = root.lookupType('Chat2Message');
    }

    initSDS() {
      // Initialize SDS Message Channel
      this.messageChannel = new MessageChannel('retro-chat');

      // Listen for SDS events
      this.messageChannel.addEventListener(MessageChannelEvent.MessageSent, (event) => {
        console.log('SDS: Message sent', event.detail);
      });

      this.messageChannel.addEventListener(MessageChannelEvent.MessageDelivered, (event) => {
        console.log('SDS: Message delivered', event.detail);
      });

      this.messageChannel.addEventListener(MessageChannelEvent.MessageReceived, (event) => {
        console.log('SDS: Message received event triggered', event.detail);
        // Process the received message immediately
        this.handleSDSMessage(event.detail);
      });

      this.messageChannel.addEventListener(MessageChannelEvent.MessageAcknowledged, (event) => {
        console.log('SDS: Message acknowledged', event.detail);
        this.updateMessageStatusBySDSId(event.detail, 'acknowledged');
      });

      this.messageChannel.addEventListener(MessageChannelEvent.PartialAcknowledgement, (event) => {
        console.log('SDS: Partial acknowledgement', event.detail);
      });

      this.messageChannel.addEventListener(MessageChannelEvent.MissedMessages, async (event) => {
        if (event.detail.length > 0) {
          console.log('SDS: Missed messages detected', event.detail);
          this.addSystemMessage(`SDS: Detected ${event.detail.length} missed messages, retrieving...`);

          // Retrieve missed messages using their message IDs
          await this.retrieveMissedMessages(event.detail);
        }
      });

      // Process SDS tasks regularly and handle message sweeping
      setInterval(async () => {
        try {
          await this.messageChannel.processTasks();

          // Sweep incoming buffer to check for deliverable messages
          const missingMessages = this.messageChannel.sweepIncomingBuffer();
          if (missingMessages.length > 0) {
            console.log('SDS: Missing messages detected:', missingMessages.length);
          }
        } catch (error) {
          console.error('Error processing SDS tasks:', error);
        }
      }, 1000);

      // Send sync messages every 30 seconds
      setInterval(async () => {
        if (this.node && this.status.classList.contains('connected')) {
          try {
            await this.messageChannel.sendSyncMessage(async (syncMessage) => {
              // Send sync message via Waku
              await this.node.lightPush.send(this.encoder, {
                payload: encodeMessage(syncMessage)
              });
              return true;
            });
            console.log('SDS: Sent sync message');
          } catch (error) {
            console.error('Failed to send sync message:', error);
          }
        }
      }, 30000); // Every 30 seconds
    }

    initElements() {
      this.chatContainer = document.getElementById('chatContainer');
      this.messageInput = document.getElementById('messageInput');
      this.sendButton = document.getElementById('sendButton');
      this.nicknameInput = document.querySelector('.nickname-input');
      this.status = document.getElementById('status');
      this.nodeCount = document.getElementById('nodeCount');
      this.nodeTooltip = document.getElementById('nodeTooltip');

      // Set the random nickname in the input field
      this.nicknameInput.value = this.nickname;
    }

    initEventListeners() {
      this.sendButton.addEventListener('click', () => this.sendMessage());

      // Handle Enter key for sending messages
      this.messageInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          this.sendMessage();
        }
      });

      this.nicknameInput.addEventListener('change', (e) => {
        this.nickname = e.target.value.trim() || this.generateRandomNickname();
        this.addSystemMessage(`Nickname changed to: ${this.nickname}`);
      });

      // Also handle Enter for nickname input
      this.nicknameInput.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          this.nickname = e.target.value.trim() || this.generateRandomNickname();
          this.addSystemMessage(`Nickname changed to: ${this.nickname}`);
          this.messageInput.focus(); // Focus back to message input
        }
      });
    }

    async initWaku() {
      try {
        this.updateStatus('Connecting...', 'connecting');
        this.updateNodeCount(0);

        // Create Waku node
        this.node = await createLightNode({ defaultBootstrap: true });
        await this.node.start();

        // Dial the specific node
        const multiAddrWithId = '/dns4/waku.fryorcraken.xyz/tcp/8000/wss/p2p/16Uiu2HAmMRvhDHrtiHft1FTUYnn6cVA8AWVrTyLUayJJ3MWpUZDB';
        try {
          await this.node.dial(multiAddrWithId);
          console.log('Successfully dialed custom Waku node');
        } catch (dialError) {
          console.warn('Failed to dial custom node:', dialError);
        }

        this.updateStatus('Waiting for peers...', 'connecting');

        // Wait for connection to remote peers
        await waitForRemotePeer(this.node, [Protocols.LightPush, Protocols.Filter]);

        // Create encoder and decoder
        this.encoder = this.node.createEncoder({ contentTopic: this.contentTopic });
        this.decoder = this.node.createDecoder({ contentTopic: this.contentTopic });

        // Subscribe to messages
        await this.node.filter.subscribe([this.decoder], (message) => {
          this.handleIncomingWakuMessage(message);
        });

        this.updateStatus('Loading history...', 'connecting');

        // Query store for messages from the past 24 hours
        await this.loadMessageHistory();

        this.updateStatus('Connected', 'connected');
        this.messageInput.disabled = false;
        this.sendButton.disabled = false;

        // Start monitoring node connections
        this.startNodeCountMonitoring();

        this.addSystemMessage('Connected to Waku network with SDS reliability! You can now chat.');

      } catch (error) {
        console.error('Failed to initialize Waku:', error);
        this.updateStatus('Connection failed', 'error');
        this.addSystemMessage(`Connection failed: ${error.message}`);
      }
    }

    startNodeCountMonitoring() {
      // Update node count immediately and then every 5 seconds
      this.updateNodeCountFromWaku();
      setInterval(() => {
        this.updateNodeCountFromWaku();
      }, 5000);
    }

    async updateNodeCountFromWaku() {
      if (this.node && this.node.libp2p && this.node.libp2p.getConnections) {
        try {
          const connections = this.node.libp2p.getConnections();
          const activeConnections = connections.filter(conn => conn.status === 'open');
          const connectedPeers = activeConnections.length;

          // Get peer addresses for tooltip and extract domain names
          const peerAddresses = activeConnections.map(conn => {
            const remoteAddr = conn.remoteAddr;
            if (remoteAddr) {
              const addrString = remoteAddr.toString();
              return this.extractDomainFromAddress(addrString);
            }
            return 'Unknown address';
          });

          this.updateNodeCount(connectedPeers, peerAddresses);
        } catch (error) {
          // Fallback if getConnections method doesn't exist or fails
          console.warn('Could not get connection count:', error);
          this.updateNodeCount(0, []);
        }
      }
    }

    extractDomainFromAddress(address) {
      try {
        // Handle different multiaddr formats
        // Examples:
        // /dns4/node-01.do-ams3.waku.test/tcp/8000/ws/p2p/16Uiu2...
        // /ip4/127.0.0.1/tcp/60001/ws/p2p/16Uiu2...
        // /dns/bootstrap.libp2p.io/tcp/443/wss/p2p/QmNnooDu7...

        const parts = address.split('/');

        // Look for dns4, dns6, or dns parts
        for (let i = 0; i < parts.length - 1; i++) {
          if (parts[i] === 'dns4' || parts[i] === 'dns6' || parts[i] === 'dns') {
            return parts[i + 1];
          }
        }

        // If no domain found, look for IP address
        for (let i = 0; i < parts.length - 1; i++) {
          if (parts[i] === 'ip4' || parts[i] === 'ip6') {
            return parts[i + 1];
          }
        }

        // Fallback: return the original address if we can't parse it
        return address;
      } catch (error) {
        return address;
      }
    }

    updateStatus(text, className) {
      this.status.textContent = text;
      this.status.className = `status ${className}`;
    }

    updateNodeCount(count, addresses = []) {
      const nodeCountSpan = this.nodeCount.firstChild;
      nodeCountSpan.textContent = `Nodes: ${count}`;

      // Update tooltip content
      if (count === 0) {
        this.nodeTooltip.textContent = 'No connections';
      } else {
        this.nodeTooltip.innerHTML = addresses
          .map(addr => `<span class="tooltip-address">${this.escapeHtml(addr)}</span>`)
          .join('');
      }
    }

    async sendMessage() {
      const text = this.messageInput.value.trim();
      if (!text || !this.node || !this.Chat2Message) return;

      // Disable input temporarily
      this.messageInput.disabled = true;
      this.sendButton.disabled = true;

      // Clear input immediately
      const originalText = text;
      this.messageInput.value = '';

      // Create a temporary message ID for tracking
      const messageId = Date.now() + '-' + Math.random();

      try {
        // Create protobuf message
        const chatMessage = {
          timestamp: Math.floor(Date.now() / 1000), // Unix timestamp in seconds
          nick: this.nickname,
          payload: new TextEncoder().encode(originalText)
        };

        // Encode with protobuf
        const protoMessage = this.Chat2Message.create(chatMessage);
        const payload = this.Chat2Message.encode(protoMessage).finish();

        // Add the message to chat with sending status
        const messageElement = this.addChatMessageWithStatus({
          timestamp: Date.now(),
          sender: this.nickname,
          text: originalText,
          messageId: messageId,
          status: 'sending'
        });

        // Send through SDS for reliability
        await this.messageChannel.sendMessage(payload, async (sdsMessage) => {
          try {
            // Create Waku message with SDS wrapper
            const wakuMessage = { payload: encodeMessage(sdsMessage) };

            // Send via Waku LightPush
            const result = await this.node.lightPush.send(this.encoder, wakuMessage);

            // Update message status to sent and track SDS message ID
            this.updateMessageStatus(messageId, 'sent');
            this.pendingMessages.set(sdsMessage.messageId, messageId);

            // Update the SDS ID in the message element
            this.updateMessageSDSId(messageId, sdsMessage.messageId);

            // Return success with message hash as retrieval hint
            // The message hash can be used later to query the store directly
            return {
              success: true,
              retrievalHint: this.node.store.createCursor(wakuMessage)
            };
          } catch (error) {
            console.error('Failed to send via Waku:', error);
            return { success: false };
          }
        });

      } catch (error) {
        console.error('Failed to send message:', error);
        this.addSystemMessage(`Failed to send message: ${error.message}`);
        // Restore the message on error
        this.messageInput.value = originalText;
      } finally {
        // Re-enable input
        this.messageInput.disabled = false;
        this.sendButton.disabled = false;
        this.messageInput.focus();
      }
    }

    async handleIncomingWakuMessage(wakuMessage) {
      try {
        if (!wakuMessage.payload) {
          console.log('Waku: Received message with no payload');
          return;
        }

        console.log('Waku: Received message, payload length:', wakuMessage.payload.length);

        // Decode SDS message
        const sdsMessage = decodeMessage(wakuMessage.payload);
        console.log('Waku: Decoded SDS message:', sdsMessage);

        // Process through SDS message channel
        this.messageChannel.receiveMessage(sdsMessage);

        // Process SDS tasks immediately to handle the received message
        await this.messageChannel.processTasks();
        console.log('Waku: Processed SDS tasks');

      } catch (error) {
        console.error('Failed to process incoming Waku message (SDS only):', error);
      }
    }

    handleSDSMessage(sdsMessage) {
      try {
        if (!sdsMessage.content || sdsMessage.content.length === 0) {
          // This is a sync message, ignore for chat display
          console.log('SDS: Received sync message, ignoring for chat display');
          return;
        }

        console.log('SDS: Processing message with content length:', sdsMessage.content.length);
        console.log('SDS: Full message object:', sdsMessage);

        // Decode the chat message from SDS content
        const decodedMessage = this.Chat2Message.decode(sdsMessage.content);

        const message = {
          timestamp: Number(decodedMessage.timestamp) * 1000, // Convert to milliseconds
          sender: decodedMessage.nick,
          text: new TextDecoder().decode(decodedMessage.payload),
          sdsMessageId: sdsMessage.messageId || 'unknown'
        };

        console.log('SDS: Decoded message from', message.sender, ':', message.text, 'SDS ID:', message.sdsMessageId);

        // Only add if it's not from ourselves (to avoid duplicates)
        if (message.sender !== this.nickname) {
          this.addChatMessage(message);
          console.log('SDS: Added message to chat from', message.sender, 'with SDS ID:', message.sdsMessageId);
        } else {
          console.log('SDS: Ignoring own message');
        }

      } catch (error) {
        console.error('Failed to process SDS message:', error);
      }
    }

    updateMessageStatusBySDSId(sdsMessageId, status) {
      const messageId = this.pendingMessages.get(sdsMessageId);
      if (messageId) {
        this.updateMessageStatus(messageId, status);
        if (status === 'acknowledged') {
          // Remove from pending messages once acknowledged
          this.pendingMessages.delete(sdsMessageId);
        }
      }
    }

    addChatMessage(message) {
      const messageElement = document.createElement('div');
      messageElement.className = 'message';

      const timestamp = new Date(message.timestamp).toLocaleTimeString();
      const sdsId = message.sdsMessageId ? this.truncateSDSId(message.sdsMessageId) : 'no-id';

      console.log('Adding chat message with SDS ID:', message.sdsMessageId, 'truncated to:', sdsId);

      messageElement.innerHTML = `
        <div class="message-content">
          <span class="timestamp">[${timestamp}]</span>
          <span class="sender">&lt;${this.escapeHtml(message.sender)}&gt;</span>
          <span class="message-text"> ${this.escapeHtml(message.text)}</span>
        </div>
        <div class="sds-id" title="SDS ID: ${message.sdsMessageId || 'Unknown'}">${sdsId}</div>
      `;

      this.chatContainer.appendChild(messageElement);
      this.scrollToBottom();

      return messageElement;
    }

    addHistoricalChatMessage(message) {
      const messageElement = document.createElement('div');
      messageElement.className = 'message historical-message';

      const timestamp = new Date(message.timestamp).toLocaleTimeString();
      const date = new Date(message.timestamp).toLocaleDateString();
      const sdsId = message.sdsMessageId ? this.truncateSDSId(message.sdsMessageId) : 'hist-id';

      console.log('Adding historical message with SDS ID:', message.sdsMessageId, 'truncated to:', sdsId);

      messageElement.innerHTML = `
        <div class="message-content">
          <span class="timestamp">[${date} ${timestamp}]</span>
          <span class="sender">&lt;${this.escapeHtml(message.sender)}&gt;</span>
          <span class="message-text"> ${this.escapeHtml(message.text)}</span>
        </div>
        <div class="sds-id" title="SDS ID: ${message.sdsMessageId || 'Historical message'}">${sdsId}</div>
      `;

      this.chatContainer.appendChild(messageElement);

      return messageElement;
    }

    addChatMessageWithStatus(message) {
      const messageElement = document.createElement('div');
      messageElement.className = 'message';
      messageElement.dataset.messageId = message.messageId;

      const timestamp = new Date(message.timestamp).toLocaleTimeString();

      const statusIcon = this.getStatusIcon(message.status);
      const statusClass = message.status;

      messageElement.innerHTML = `
        <div class="message-content">
          <span class="timestamp">[${timestamp}]</span>
          <span class="sender">&lt;${message.sender}&gt;</span>
          <span class="message-text"> ${this.escapeHtml(message.text)}</span>
        </div>
        <div class="message-status ${statusClass}">${statusIcon}</div>
        <div class="sds-id" title="SDS ID will appear after sending">...</div>
      `;

      this.chatContainer.appendChild(messageElement);
      this.scrollToBottom();

      return messageElement;
    }

    getStatusIcon(status) {
      switch (status) {
        case 'sending':
          return '◐';
        case 'sent':
          return '<span class="tick">✓</span>';
        case 'acknowledged':
          return '<span class="tick">✓</span><span class="tick second">✓</span>';
        default:
          return '◐';
      }
    }

    updateMessageStatus(messageId, status) {
      const messageElement = this.chatContainer.querySelector(`[data-message-id="${messageId}"]`);
      if (messageElement) {
        const statusElement = messageElement.querySelector('.message-status');
        if (statusElement) {
          statusElement.className = `message-status ${status}`;
          statusElement.innerHTML = this.getStatusIcon(status);
        }
      }
    }

    updateMessageSDSId(messageId, sdsMessageId) {
      const messageElement = this.chatContainer.querySelector(`[data-message-id="${messageId}"]`);
      if (messageElement) {
        const sdsElement = messageElement.querySelector('.sds-id');
        if (sdsElement && sdsMessageId) {
          const truncatedId = this.truncateSDSId(sdsMessageId);
          sdsElement.textContent = truncatedId;
          sdsElement.title = `SDS ID: ${sdsMessageId}`;
        }
      }
    }

    truncateSDSId(sdsMessageId) {
      // Show first 6 characters of SDS message ID for discreteness
      if (!sdsMessageId) return 'no-id';
      return sdsMessageId.length > 6 ? sdsMessageId.substring(0, 6) + '...' : sdsMessageId;
    }

    addSystemMessage(text) {
      const messageElement = document.createElement('div');
      messageElement.className = 'message system-message';
      messageElement.innerHTML = `
        <div class="message-content">[SYSTEM] ${text}</div>
      `;

      this.chatContainer.appendChild(messageElement);
      this.scrollToBottom();
    }

    escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    scrollToBottom() {
      this.chatContainer.scrollTop = this.chatContainer.scrollHeight;
    }
  }

  // Initialize the chat application
  window.addEventListener('DOMContentLoaded', () => {
    new RetroIRC();
  });
</script>
</body>
</html>
